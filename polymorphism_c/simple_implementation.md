Բազմաձևության իրականացում C լեզվով
=============================
  Ողջույն։ Եթե ծանոթ եք օբյեկտ կողմնորոշված ծրագրավորման (ՕԿԾ) գաղափարին, ապա, ըստ երևույթին, առընչվել եք նաև բազմաձևության([պոլիմորֆիզմ](http://en.wikipedia.org/wiki/Polymorphism_%28computer_science%29)) հետ։ 

  Չխորանալով սահմանումների և տերմինաբանության մեջ կարող ենք ասել, որ բազմաևությունը մեխանիզմ է, որն ապահովում է "Մեկ ինտերֆեյս, տարբեր իրականացումներ մեխանիզմը"։ Վերջինս C++երեն հնչում է այսպես.
>  Բազմաևությունը հնարավորություն է տալիս բազային դասի ցուցիչով կանչել ժառանգ դասերի համար վերասահմանված մեթոդները։ 
  
  Նման մեխանիզմ իրականացնելու համար ծրագրավորման լեզվի մշակողները տարբեր մոտեցումներ ունեն, սակայն այս գրառման մեջ կդիտարկվի դրանցից միայն մեկը՝ վիրտուալ մեթոդների աղուսյակով բազմաձևության կազմակերպումը։ 
  
  Նախ դիտարկենք օրինակ C++ լեզվով, ինչից հետո նույն օրինակը կիրականացնենք C-ով։ 
  
  Օրինակը հետևյալն է․
> Ունենք Animal դաս, որն օժտված է say() մեթոդով։ Մեթոդն էկրանին դուրս է բերում "Animal says Hello!" արտահայտությունը։  
> Animal դասն ունի երկու ժառանգ Tiger և Lion, որոնցում համապատասխանաբար վերասահմանված է say() մեթոդը։ 
> Խնդիրը կայանում է նրանում, որ պետք է Animal* տիպի ցուցիչով կարողանանք դիմել նաև Tiger և Lion դասերում վերասահմանված say() մեթոդին և էկրանին ստանանք ճիշտ հաղորդագրություն։ 

### Իրականացումը C++ով 
  
  ```c++
  // սահմանում ենք Animal դասը 
  class Animal {
  public:
  	// ուշադրություն դարձրեք, որ say մեթոդը սահմանված է, որպես
  	// վիրտուալ (virtual բանալի բառով)
	  virtual void say(){
		  cout << "Animal says hello!" << endl;	
	  }
  };
  
  // սահմանում ենք Tiger դասը ժառանգելով Animal դասից
  class Tiger : public Animal {
  public:
  	  // քանի որ բազային դասում say()-ը նշված է որպես virtual
  	  // վերասահմանելիս կարելի է virtual բառը բաց թողնել
	  virtual void say(){
		  cout << "Tiger says hello!" << endl;	
	  }
  };

  // սահմանում ենք Lion դասը ժառանգելով Animal դասից
  class Lion : public Animal {
  public:
	  virtual void say(){
		  cout << "Lion says hello!" << endl;	
	  }
  };

  ```
  
  Օրինակն իրականացված է։ Մնում է գրենք կիրառությունը։
  ```c++
  int main(){
    // սահմանենք 3 օբյեկտ բազային դասի ցուցիչով 
    
    // Animal օբյեկտ Animal* ցուցիչով
    Animal* animalPtr = new Animal();
    
    // Tiger օբյեկտ Animal* ցուցիչով
    Animal* tigerPtr = new Tiger();
    
    // Lion օբյեկտ Animal* ցուցիչով
    Animal* lionPtr = new Lion();
    
    /* say մեթոդի կանչ */
    animalPtr->say(); // Animal::say()
    tigerPtr->say(); // Tiger::say()
    lionPtr->say(); // Lion::say()
    
    /* կըտոր մը մաքրութիւն */
    delete lionPtr;
    delete tigerPtr;
    delete animalPtr;
    
    // ծրագրի հաջող ավարտ
    return 0;
}
  ```

  Եթե մեթոդները վերասահմանված չլինեին որպես virtual, ապա երեք անգամ կկանչվեր Animal::say() մեթոդը։ Համոզվելու համար բավական է հեռացնել virtual բառը։ 

  Իսկ ինչպե՞ս է այս ամենն աշխատում։ Ինչպե՞ս է թարգմանիչը հասկանում, որ դասի մեթոդը կանչել (չէ որ երեք դեպքում էլ դիմում ենք Animal* տիպի ցուցչի)։ 

  Մեխանիզմը հետևյալն է`
  	1. ամեն դասի համար ստեղծվում է վիրտուալ մեթոդների աղուսյակ (vtable) 
  	2. աղուսյակը մասնավորապես կարող է իրականացված լինել որպես կառուցվածք (ստորեվ բերված օրինակում) կամ երկչափ զանգված 
  	3. derive.vtable.virtualFunction դաշտին վերագրվում է համապատասխան վերասահմանված ֆունկցիայի ցուցիչը
  	4. derived.virtualFunction() դիպի կանչը փոխարինվում է derived.vtable.virtualFunction()
